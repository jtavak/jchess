use crate::types::*;

// the idea of magic bitboards is explained here: https://www.chessprogramming.org/Magic_Bitboards
// these numbers are used in a function which hashes occupancy bits to index the set of attack masks, providing extremely fast move generation for sliding pieces

pub const ROOK_MAGICS: [Bitboard; 64] = 
    [0x0080048122400014, 0x08c0200440001000, 0x12001200c2200880, 0x2a00084020d00600, 0x2200060020040810, 0x00800e0080292400, 0x8080020015004180, 0x4e00008020440116,
     0x12008004934000a2, 0x20c2004483060020, 0x0402001205a0c280, 0x8e2a00200831c200, 0x4087005008000500, 0x00a2004462001008, 0x02840006080c5043, 0x040a000080ca0403,
     0x9844608000400284, 0x2740820040210201, 0x2540460032002081, 0x01d2290010010162, 0x320801001009000c, 0x5881818006000400, 0x8c0ba40003020890, 0x00018a001841019c,
     0x6484400280036480, 0x5815820600224500, 0x8812008200201049, 0x1202090100225000, 0x1942220200182250, 0x0b0ac01801200470, 0x0006050c00308228, 0x48416c0a002180c1, 
     0x98808840108000e3, 0x643006600c400148, 0x8861806000805000, 0x8604211901005000, 0x2812480111001500, 0x8b9e01108e00080c, 0x15800a488c000510, 0xb8070004c500028a, 
     0x4036048101420024, 0x1c03d00320084000, 0x50216081c6020011, 0x950501c890030020, 0x2016003034220008, 0x140ef0400c180120, 0x80448810010c0002, 0xc120040441820003, 
     0xb026420693002200, 0xa020a30202934200, 0x80e6805007a00480, 0x1010402019120200, 0xaf22002009108600, 0x0088e02c40100801, 0x2020b00208318400, 0xa8d100104a218300, 
     0x1480009863008241, 0x8a0c148100c00423, 0x80e3098012004022, 0x1c59001000083c21, 0x890e0030200408c2, 0x4062004104081002, 0x903846100108880c, 0x8207e44111840022
    ];

pub const BISHOP_MAGICS: [Bitboard; 64] = 
    [0x3520020417040992, 0x801c042801510814, 0xc0d0610043011c57, 0x010a0a020a880008, 0x8b0d104028413468, 0x09230b08c08c4041, 0x83a8482210100129, 0xdc07002109284001, 
     0x00001010100354c0, 0x5401824232040500, 0x06810608010f062c, 0x2408080a1022441d, 0x81208c1044428b05, 0x6c20690160508203, 0x00040a0101209000, 0x221cc60214820800, 
     0x6090011a30501490, 0x5c30cd28124c8400, 0x961a041c04017200, 0x0010204504008040, 0x0204000d94201d02, 0x8061002204410400, 0x204a008403635b80, 0x201e025111c11c08, 
     0x10100828c018518b, 0x282a0a0590705a22, 0x02a828043010c040, 0x39c9040108020820, 0x04008c0003802014, 0x0404ca0041010121, 0xac11820044010474, 0x00858468ab011808, 
     0x1131202041082800, 0x220086700018501a, 0x0100108800b0004d, 0x112c6a8081380200, 0x5120008400208020, 0xb403850500020488, 0x001e118102442c09, 0x39d424002b624109, 
     0xe148680c10484400, 0xc0c548026852b00c, 0x1609001982085000, 0x0664602018000300, 0x231d40490a024500, 0x08205c0088081880, 0x100212080107020c, 0x2002140407800420, 
     0x6e43182206201100, 0x0402088088183272, 0x8209710c1f040485, 0x410102d062880602, 0x8d8d001012060004, 0x1cb1201204484431, 0x425202302b020408, 0x31d2081b15021003, 
     0x0084802801100829, 0x804312030901b010, 0x003820a04203900a, 0x3a42401044420200, 0x011b246a40892600, 0x9025384004280223, 0xa20821e017021080, 0x1541340800410721
    ];

// magics computed using this code
// use deltas = [7, 9, -7, -9] for bishops

// let mut rng = rand::thread_rng();

// let mut magics: [Bitboard; 64] = [BB_NONE; 64];
// let deltas = [-1, 1, -8, 8];
// for sq in 0..64 {
//     // generate the mask
//     let edge_mask: Bitboard = ((BB_RANK_1 | BB_RANK_8) & !rank_bb(sq)) | (BB_FILE_A | BB_FILE_H) & !file_bb(sq);
//     let mask: Bitboard = slider_mask(sq, &deltas, BB_NONE) & !edge_mask;
//     let shift: u8 = 64-popcount(mask);

//     // brute force to find working magic
//     let mut magic: Bitboard;
//     'outer: loop {
//         let mut indices: Vec<bool> = vec![false; usize::pow(2, 64-shift as u32)];
//         magic = rng.gen::<Bitboard>() & rng.gen::<Bitboard>();

//         // cool trick to iterate over subsets of the mask
//         let mut n: Bitboard = BB_NONE;
//         'inner: loop {
//             let index: usize  = ((n.wrapping_mul(magic)) >> shift) as usize;
//             if indices[index] == true {
//                 break 'inner
//             }
//             indices[index] = true;

//             n = (n.wrapping_sub(mask)) & mask;
//             if n == 0 {
//                 break 'outer
//             }
//         }
//     }
    
//     magics[sq] = magic;
// }